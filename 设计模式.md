# 概述

设计模式的学习通过大话设计模式这本书来学习

# 简单工厂模式

知识点总结

1. 注意代码规范，例如命名

2. 将业务逻辑与界面逻辑分开

   在文中这部分实现是通过产生运算类，界面通过调用运算类得到结果

3. 对运算类做了改进，都继承同一个类

   在客户端实例化不同的运算类，来进行运算

   工厂模式具体如下

   1. 客户端调用工厂类，根据运算符号生成，生成对应的运算类
   2. 运算类调用自己的方法得到结果

4. UML类图的概念

   * 类的表示
   * 接口的表示
   * 继承的表示方法
   * 关联
   * 拥有
   * 合成

# 策略模式

[简单工厂模式和策略模式的比较_张伟杰-CSDN博客_策略模式和工厂模式的区别](https://blog.csdn.net/zwj_jyzl/article/details/80869905)

简单工厂模式和策略模式比较相似，尤其简单工厂模式和策略模式结合之后，更加相似，上面这一篇讲解的不错。

简单工厂模式：根据客户选择的条件，来帮客户创建一个对象。
策略模式：客户给它一个创建好的对象，它来帮客户做相应的事。

简单工厂模式属于创建模式

策略模式属于行为模式

# 单一职责原则

就一个类而言，应该仅有一个引起他变化的原因

如果一个类承担的职责过多，就等于把这写职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。

# 开放封闭原则

如果软件实体（类，模块，函数等等）应该可以扩展，但是不可修改。

面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。

# 装饰模式

例子人穿衣服，直接写的话，每次变化衣服，需要在person类里面进行修改，修改很多方法。

如果人和衣服分开，具体衣服为服饰类的子类。需要创建很多个类，每个类的show方法不同。

**装饰模式**：动态地给一个对象添加一些额外的职责，就增加功能来说。装饰模式比生成子类灵活。

装饰模式是利用setComponet来对对象进行包装的，这样每个装饰对象的实现就跟如何使用这个对象分离开了，每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中

装饰模式是为已有功能动态地添加更多功能的一种方式。

# 代理模式

为其他对象提供一种代理以控制对这个对象的访问。

代理和真实实体都实现同一个接口，代理里面保存一个引用可以访问实体。方法实现调用实体的方法。

# 工厂方法模式

简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。但是每次修改都要修改工厂类。违背了开放封闭原则。

**工厂方法模式**：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

# 原型模式

用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

其中复制包括浅复制和深复制

# 模板方法模式

要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理。

**模板方法模式** 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

模板方法是通过把不变行为搬移到超类，去除子类中的重复代码来体现他的优势。

# 迪米特法则

如果两个类不必彼此通信，那么这两个类就不应当发生直接的相互作用，如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个应用。

# 外观模式

为子系统的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

# 建造者模式

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

